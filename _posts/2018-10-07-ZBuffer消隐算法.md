---
layout: post
title:  "zbuffer消隐算法"
date:   2018-10-07 20:00:00
categories: MacroDog
tags: 计算机图形学 消隐算法
excerpt: 消隐算法
mathjax: true
---
* content
{:toc}
#原理
算法中使用两个数组用于对图像信息保持
属性数组
Intensity(x,y) 帧缓存器 用于存储图像空间每个可见像素的光强和颜色
深度数组
Depth(x,y)  z-buffer  用于存储图像空间每个可见像素的z坐标（投影变换后）
#思想
(1)初始化z-buffer  将数组中值全部置为最小值
(2)改变坐标(x,y)的像素点颜色时将该像素点的深度值与与z-buffer中的值比较如果深度值大于缓存区的则将像素点的深度值写入z-buffer，并且改变帧缓存区的值（颜色）。

##伪码
z-buffer算法(){
    帧缓存全置为背景色
    深度缓存全置为最小值
    for(多边形){
        扫描转换多边形
        for(多边形像素点(x,y)){
            计算该多边形在该像素的深度值Z(x,y)
            if(Z(x,y)>ZBuffer(x,y)){
                ZBuffer(x,y)= Z(x,y)
                帧缓存(x,y)= 多边形(x,y)信息 
            }
        }
    }
}
#优缺点
##优点
(1) 简单直观
(2) 在像素级上进物取代远物。与物体在屏幕上的出现顺序无关，有利于硬件上的实现
(3) 在内存容量不再是问题后变得受欢迎。
##缺点
(1) 占空间大
(2) 没有利用图形的相关性和连续性。

#改进
使用一个深度缓冲变量来替代z-buffer数组
##伪码
z-buffer算法(){
    帧缓存全置为背景色
    for(屏幕上像素(x,y)){
        深度缓冲变量zb置为最小值
        for(多面体上的多边形Pk){
            if(像素点(i,j)在Pk的投影多边形内){
                计算Pk(i,j)处的深度值depth;
                if(depth>zb){
                    zb = depth;
                    indexp = k;//记录多边形序号
                }
            }
        }
        if(zb!=MinValue){
                设置像素点(x,y)颜色
        }
    }
}
##要点
在判断像素点(x,y)是否在Pk的投影多边形之内，是一件很不容易的。
###点与多边形的包含性检测
#####(1)射线法
从被检测点P处向 &&y=-\infty&&方向作射线。
若交点个数是奇数，被检测点在多边形内部。
若交点个数是偶数，被检测点在多边形外部。
当射线经过多边形的顶点时若边在射线的左侧有效，右侧则无效。
弊端：
(1)求交计算量大
(2)不稳定(计算会有精度导致结果不稳定)
####(2)弧长法
以p点位圆心，作单位圆，把边投影到单位圆上，对应到弧长上，逆时针为正，顺时针为负，计算弧长代数和。
代数和为0，点在多边形外部
代数和为$2\pi$,点在多边形内部
代数和为$\pi$，点在多边形边上
弊端:
(1) 求弧长计算量不小
####(3)以顶点符号为基础的弧长累加法
